Cosas a revisar/comentar:
    - fetch de getMessage y fetchEventRecommended llevan a ruta / --> devuelven index.html ¡¡SOLUCIONADO!!
    - logout tiene su ruta, no se usa ¡¡SOLUCIONADO!!
    - passwordRecovery tiene su ruta (reset-password), no se usa? según CHATGPT está bien implementado?
    - línea 416, el fecht de qué es? el evento se añade a signedup_event del perfil del usuario en la BBDD
    - línea 458, según el endpoint de cancelación de inscripción al evento (línea 479 de routes.py), es un DELETE
    - línea 476, shareEvent según hablado con Atlas, solo por whatsapp y es de front, no necesario aquí
    - revisar con BBDD si están todos los endpoints ¡¡HECHO!!
    - BUSCA LO QUE HAS AÑADIDO COMO AÑADIDO / COMENTADO ALONDRA
    - fetchUserProfile creo que debería estar dentro del getState porque no se encuentra setStore (?)

Qué he hecho:
    - solucionar problema cors
    - solucionar errores de fetch
    - crear una función que guarda la autentificación en cookies
    - implementar en varias solicitudes la autentificación (faltaba en el header de la solicitud)
    - añadir comentarios con cambios y ajustes
    - crear los fetch que faltaban según la estructura de la BBDD

Qué no me ha salido:
    - el login funcionaba después de arreglos, ahora ya no, no entiendo qué problema hay

Fetch que creo que faltan:
deleteUser: async (userId) => {
    try {
        // Realiza una solicitud DELETE al backend para eliminar un usuario específico
        const response = await fetch(`${process.env.BACKEND_URL}/api/users/${userId}`, {
            method: 'DELETE',
            headers: {
                'X-CSRF-TOKEN': getCookie('access_token')
            }
        });

        if (!response.ok) {
            throw new Error('Failed to delete user');
        }

        // Maneja la respuesta si es necesario
        console.log('User deleted successfully');

    } catch (error) {
        console.error('Error deleting user:', error);
        throw error;
    }
},

deleteEvent: async (eventId) => {
    try {
        // Realiza una solicitud DELETE al backend para eliminar un evento específico
        const response = await fetch(`${process.env.BACKEND_URL}/api/events/${eventId}`, {
            method: 'DELETE',
            headers: {
                'X-CSRF-TOKEN': getCookie('access_token')
            }
        });

        if (!response.ok) {
            throw new Error('Failed to delete event');
        }

        // Maneja la respuesta si es necesario
        console.log('Event deleted successfully');

    } catch (error) {
        console.error('Error deleting event:', error);
        throw error;
    }
},

getEventsByUser: async (userId) => {
    try {
        const response = await fetch(`${process.env.BACKEND_URL}/api/users/${userId}/events`, {
            headers: {
                'X-CSRF-TOKEN': getCookie('access_token')
            }
        });
        if (!response.ok) {
            throw new Error('Failed to fetch events by user');
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error("Error fetching events by user:", error);
        throw error;
    }
},

getUsersByEvent: async (eventId) => {
    try {
        const response = await fetch(`${process.env.BACKEND_URL}/api/events/${eventId}/users`, {
            headers: {
                'X-CSRF-TOKEN': getCookie('access_token')
            }
        });
        if (!response.ok) {
            throw new Error('Failed to fetch users by event');
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error("Error fetching users by event:", error);
        throw error;
    }
},

addEventToFavorites: async (userId, eventId) => {
    try {
        const response = await fetch(`${process.env.BACKEND_URL}/api/users/${userId}/events/${eventId}/favorite`, {
            method: "POST",
            headers: {
                'X-CSRF-TOKEN': getCookie('access_token')
            }
        });
        if (!response.ok) {
            throw new Error('Failed to add event to favorites');
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error("Error adding event to favorites:", error);
        throw error;
    }
},

removeEventFromFavorites: async (userId, eventId) => {
    try {
        const response = await fetch(`${process.env.BACKEND_URL}/api/users/${userId}/events/${eventId}/favorite`, {
            method: "DELETE",
            headers: {
                'X-CSRF-TOKEN': getCookie('access_token')
            }
        });
        if (!response.ok) {
            throw new Error('Failed to remove event from favorites');
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error("Error removing event from favorites:", error);
        throw error;
    }
},

getUserFavoriteEvents: async (userId) => {
    try {
        const response = await fetch(`${process.env.BACKEND_URL}/api/users/${userId}/favorite_event`, {
            headers: {
                'X-CSRF-TOKEN': getCookie('access_token')
            }
        });
        if (!response.ok) {
            throw new Error('Failed to fetch user favorite events');
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error("Error fetching user favorite events:", error);
        throw error;
    }
};

searchEventsByType: async (eventType) => {
    try {
        const response = await fetch(`/api/events/search?type=${eventType}`);
        const data = await response.json();
        return data;
    } catch (error) {
        console.error("Error searching events by type:", error);
        throw new Error("Error searching events by type");
    }
};

filterEvents: async (filters) => {
    try {
        const queryString = new URLSearchParams(filters).toString();
        const response = await fetch(`/api/events/filter?${queryString}`);
        const data = await response.json();
        return data;
    } catch (error) {
        console.error("Error filtering events:", error);
        throw new Error("Error filtering events");
    }
};
